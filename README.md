# 내 손은 금손

> 사용자가 화면에 그린 그림을 동그라미, 세모, 네모, 별, 네 가지 모양 중 하나로 판별하여 결과와 정확도를 출력해주는 앱

![ezgif com-gif-maker](https://user-images.githubusercontent.com/73573732/117704636-0813df00-b206-11eb-820d-91d4127270f0.gif)

## 1. 함께한 사람들

- 팀원 및 기간: [Bam](https://github.com/hcooch2ch3)과 함께 2021.04.29 ~ 2021.04.30, 총 2주 동안 진행
- 코드 리뷰어: [daheenallwhite](https://github.com/daheenallwhite)
- 학습에 도움을 주신 분: [미정님](https://github.com/MijeongJeon)

## 2. 앱 구현 과정

### 2.1 CoreML 모델 학습

 CreateML과 Keras를 통한 모델의 학습을 진행했습니다. 전자의 경우 Xcode에 포함된 CreateML 툴을 사용해서 진행했고, 후자의 경우 Google의 Colab을 통해 진행했습니다.

<***해당 부분에서 했던 고민점들***>

* CreateML과 Keras를 모두 사용해서 모델을 두 개 만들었는데, 신기하게 파일 용량에서 꽤 차이가 났습니다. CreateML로 학습한 파일은 50KB로 비교적 작은 반면, Keras로 학습한 파일은 4.8MB로 용량이 비교적 컸습니다.
  * iOS 11 부터 CoreML이, iOS 12 부터 CoreML2와 CreateML이 함께 출시되었습니다. Keras는 CoreML을 기반으로, CreateML은 CoreML2를 기반으로 동작합니다. CoreML은 가중치 값이 `Float32` 로 저장되어있지만, CoreML2은 가중치 값을 양자화를 통해 1~8 bit 까지 줄일 수 있습니다. 그렇기에 용량차이가 발생하게 된 것입니다. 하지만 Keras에서도 양자화 코드를 따로 입력하면 용량을 줄일 수 있습니다.

### 2.2 UI 구현

 스토리보드로 작업 후 Merge 시에 발생하는 충돌 및 각종 스토리보드 버그를 피하기 위해 코드로 UI를 구현했습니다. 스토리보드 파일을 삭제하고, 스토리보드와 관련된 `Info.plist`의 프로퍼티들을 제거했습니다. 이 후, 편한 배치를 위해 `UIStackView`를 활용했고 배경보다 캔버스에 집중되는 효과를 위해 단순히 배경에 색상을 주는 것이 아닌, `UIVisualEffectView` 를 사용하여 구현했습니다.

<***해당 부분에서 했던 고민점들***>

* `UIStackView`에서 `addArrangedSubview(_:)`을 사용해야하는 이유에 대해 고민했습니다.
  * `UIStackView`를 사용하여 컴포넌트들을 배치할 때, `addSubview(_:)`를 사용했었는데, 원하는 대로 배치가 되지 않았습니다. 그 [이유](https://developer.apple.com/documentation/uikit/uistackview/)는 `UIStackView`는 하위 뷰들을 `arrangedSubviews`라는 배열로 관리하고 있기 때문입니다. 그리고 해당 배열에 `addArrangedSubview(_:)`메서드를 사용하여 하위 뷰들을 배열 끝에 추가할 수 있습니다. 즉, `addArrangedSubview(_:)`를 호출하는 순서에 따라 `UIStackView` 배열 순서가 달라질 수 있음을 확인할 수 있었습니다.
* 배경 뷰의 색을 회색으로 처리함에 있어서 고민이 있었습니다.
  * 처음에는 간단하게 `view.backgroundColor`를 회색으로 처리하려고 했습니다. 하지만 사용자가 직관적으로 '캔버스에 그림을 그린다.' 라는 것을 알 수 있도록 구현하는 차원에서는 단순히 배경색으로 처리하는 것보다, Modal 처럼 사용에서 중요한 캔버스를 강조하고, 뒷 배경을 흐리도록 하는 것이 정황상 더 맞는 구현이라고 생각했습니다.
* `UIVisualEffectView`을 사용하게 된 이유에 대해서 고민했습니다.

### 2.3 기능 구현

 캔버스에 그림을 그릴 수 있고,  해당 이미지를 학습 모델과 비교하기 위해 이미지를 추출하도록 구현했습니다. 학습용 데이터와 이미지가 최대한 유사하도록 선 굵기 및 선 끝처리 등도 추가했습니다. 그리고 '결과보기' 버튼을 누르면 추출된 이미지를 학습 데이터를 기반으로 분류 정확도가 얼마고 어떤 도형인지 예측하도록 했습니다. 그리고 실패할 수 있는 동작에 대해 사용자에게 어떤 이유로 에러가 나는지 정확하게 전달하기 위해 기존 `returnResultLabel` 을 활용했고, 자연스럽게 실패 동작에 대해 3번 재시도하도록 재귀함수를 사용하여 구현했습니다.

<***해당 부분에서 했던 고민점들***>

* `draw(_:)`메서드가 매번 새로운 선을 그릴 때마다 이전에 그렸던 선들도 포함해서 그리기 때문에 리소스적인 낭비가 있지 않을까 고민했습니다.
  * 



## 3. 문제 해결

### 3.1 도형을 그릴 때 모서리가 매끄럽게 연결되지 않는 문제

